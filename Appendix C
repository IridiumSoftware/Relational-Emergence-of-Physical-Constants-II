import networkx as nx
import numpy as np
import random
import time

random.seed(42)
c = 2.99792458e8
l_p = 1.616255e-35
t_p = 5.391247e-44
m_p = 2.176434e-8

class MRBootstrapCurved:
    def __init__(self, n_nodes=5000, steps=600, decay=0.99995, noise=0.03):
        self.G = nx.Graph()
        self.positions = {}
        self.spinors = {}  # (u,v): (left, right) handedness
        
        for i in range(n_nodes):
            self.G.add_node(i)
            self.positions[i] = np.random.uniform(-1e-5, 1e-5, 4)
        
        for _ in range(4 * n_nodes):
            u, v = random.sample(range(n_nodes), 2)
            if u != v and not self.G.has_edge(u, v):
                self.G.add_edge(u, v, weight=random.uniform(0.1, 1.0))
                self.spinors[(min(u,v), max(u,v))] = (random.randint(0,1), random.randint(0,1))
        
        self.decay = decay
        self.noise = noise
        self.steps = steps
    
    def geodesic(self, u, v):
        du = self.positions[u] - self.positions[v]
        return np.sqrt(np.sum(du[0:3]**2) - c**2 * du[3]**2 + 1e-20)
    
    def step(self, s):
        nodes = list(self.G.nodes())
        energies = [sum(d.get('weight', 0) for _, _, d in self.G.edges(n, data=True)) for n in nodes]
        total_e = sum(energies) or 1.0
        probs = [e / total_e for e in energies]
        active = random.choices(nodes, weights=probs, k=max(1, int(0.12 * len(nodes))))
        
        for node in set(active):
            energy = sum(d.get('weight', 0) for _, _, d in self.G.edges(node, data=True))
            if energy > 1e-10:
                candidates = list(self.G.nodes())
                weights = [self.G.degree(n) / (self.geodesic(node, n) + 1e-10) for n in candidates]
                nbr = random.choices(candidates, weights=weights, k=1)[0]
                if node != nbr and not self.G.has_edge(node, nbr):
                    d = self.geodesic(node, nbr)
                    self.G.add_edge(node, nbr, weight=energy / 2.0)
                    self.spinors[(min(node,nbr), max(node,nbr))] = (int(energy % 2), int((energy * 1.1) % 2))
        
        for u, v, d in list(self.G.edges(data=True)):
            d['weight'] *= self.decay
            if d['weight'] < 1e-6:
                self.G.remove_edge(u, v)
                self.spinors.pop((min(u,v), max(u,v)), None)
        
        edges_list = list(self.G.edges())
        perturb_n = max(1, int(self.noise * len(edges_list)))
        for _ in range(perturb_n):
            if edges_list:
                u, v = random.choice(edges_list)
                if self.G.has_edge(u, v):
                    self.G[u][v]['weight'] *= random.uniform(0.94, 1.06)
                    if self.G[u][v]['weight'] < 1e-6:
                        self.G.remove_edge(u, v)
        
        for node in nodes:
            pull = np.zeros(4)
            for nbr in self.G.neighbors(node):
                du = self.positions[node] - self.positions[nbr]
                pull += du * self.G[node][nbr]['weight']
            self.positions[node] += pull * 1e-3
        
        for node in nodes:
            spin_sum = sum(s[0] + s[1] for (u,v), s in self.spinors.items() if u == node or v == node)
            self.positions[node][3] += spin_sum * 1e-6
    
    def run(self):
        t0 = time.time()
        for s in range(self.steps):
            self.step(s)
            if s % 100 == 0:
                print(f"Step {s}: Nodes {self.G.number_of_nodes()}, Edges {self.G.number_of_edges()}")
        print(f"Finished in {time.time()-t0:.1f} s")
        
        path_len = sum(nx.shortest_path_length(self.G, random.choice(list(self.G.nodes())), random.choice(list(self.G.nodes()))) for _ in range(200)) / 200
        min_w = min(d['weight'] for _,_,d in self.G.edges(data=True))
        clust = nx.average_clustering(self.G)
        
        return {
            'path_len': round(path_len, 2),
            'clust': round(clust, 3),
            'hbar': round(min_w * (l_p**2 * m_p / t_p), 3e-35),
            'G': round(clust * (l_p**3 / (m_p * t_p**2)), 3e-11)
        }

model = MRBootstrapCurved()
results = model.run()
print(results)
